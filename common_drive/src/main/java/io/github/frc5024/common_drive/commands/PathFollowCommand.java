package io.github.frc5024.common_drive.commands;

import java.io.FileWriter;
import java.io.IOException;

import ca.retrylife.ewmath.MathUtils;
import edu.wpi.first.wpilibj.geometry.Pose2d;
import edu.wpi.first.wpilibj.geometry.Translation2d;
import edu.wpi.first.wpilibj.smartdashboard.SendableBuilder;
import edu.wpi.first.wpilibj2.command.CommandBase;

import io.github.frc5024.common_drive.DriveTrainBase;
import io.github.frc5024.common_drive.types.ChassisSide;
import io.github.frc5024.lib5k.hardware.ni.roborio.fpga.FPGAClock;
import io.github.frc5024.lib5k.logging.RobotLogger;
import io.github.frc5024.lib5k.logging.RobotLogger.Level;
import io.github.frc5024.lib5k.utils.FileManagement;
import io.github.frc5024.lib5k.utils.RobotMath;
import io.github.frc5024.purepursuit.pathgen.Path;
import io.github.frc5024.purepursuit.Follower;

/**
 * PathFollowCommand is a {@link CommandBase} object generated by
 * {@link DriveTrainBase}, and can be used to follow paths with the drivetrain.
 * In the background, it also logs the robot's current position vs the goal
 * position for match analysis.
 */
public class PathFollowCommand extends CommandBase {

    // Logger
    private RobotLogger logger = RobotLogger.getInstance();

    // Path follower
    private Follower follower;

    // DriveTrain
    private DriveTrainBase driveTrain;
    private boolean inReverse;

    // Epsilon
    private double epsRadius;

    // Logfile
    private FileWriter logFile;
    private double initTime;

    /**
     * Create a PathFollowCommand. This should not be called from user code. To
     * create one of these, call DriveTrainBase.createPathingCommand() instead.
     * 
     * @param driveTrain      DriveTrain to control
     * @param path            Path to follow
     * @param inReverse       Should the path be followed in reverse?
     * @param lookaheadMeters How far to look ahead for new goal poses
     * @param epsRadius       Radius around the final pose for trigger isFinished()
     */
    public PathFollowCommand(DriveTrainBase driveTrain, Path path, boolean inReverse, double lookaheadMeters,
            double epsRadius) {

        // Configure the follower
        follower = new Follower(path, lookaheadMeters, 0.1, driveTrain.getWidthMeters());
        this.epsRadius = epsRadius;

        // Store the drivetrain
        this.driveTrain = driveTrain;
        this.inReverse = inReverse;

    }

    @Override
    public void initialize() {
        // Reset the follower
        follower.reset();
        logger.log("Reset path follower");

        // Attempt to open a log file
        try {
            logger.log("Opening a CSV logfile to save path progress to");
            this.logFile = FileManagement
                    .createFileWriter(String.format("PathFollowCommand_%.2f.csv", FPGAClock.getFPGASeconds()));

            // Write file header
            this.logFile.append("Timestamp (seconds), Robot X, Robot Y, Robot Theta, Goal X, Goal Y\n");
        } catch (IOException e) {
            logger.log("Failed to open CSV logfile. Not going to log data");
        }

        // Set the init timestamp
        initTime = FPGAClock.getFPGASeconds();

        // Set the drivetrain side
        driveTrain.setActiveSide((inReverse) ? ChassisSide.kSecondary : ChassisSide.kPrimary);
    }

    @Override
    public void execute() {

        // Get the robot's current position
        Pose2d currentPose = driveTrain.getPose();

        // Get the next goal pose
        Translation2d goalPose = follower.getNextPoint(currentPose);

        // Drive to that pose
        // We wil give an epsilon of 1cm, and override the epsilon check in isFinished()
        driveTrain.driveTo(goalPose, 0.01);

        // Try to write to the logfile
        if (logFile != null) {

            // Get the current timestamp
            double curTime = FPGAClock.getFPGASeconds();
            double dt = curTime - initTime;

            // Write line to the logfile
            try {
                logFile.append(String.format("%.2f, %.2f, %.2f, %.2f, %.2f, %.2f%n", dt,
                        currentPose.getTranslation().getX(), currentPose.getTranslation().getY(),
                        currentPose.getRotation().getDegrees(), goalPose.getX(), goalPose.getY()));
            } catch (IOException e) {
                logger.log("Failed to write line to logFile");
            }
        }

    }

    @Override
    public void end(boolean interrupted) {

        if (interrupted) {
            logger.log("Path following was interrupted.");
        } else {
            logger.log("Robot successfully reached goal pose: %s", follower.getFinalPose());
        }

        // Reset the active side
        driveTrain.setActiveSide(ChassisSide.kPrimary);

        // Stop the robot
        driveTrain.stop();

        // Save the logfile
        if (logFile != null) {
            logger.log("Saving CSV logfile");
            try {
                logFile.flush();
                logFile.close();
            } catch (IOException e) {
                logger.log("Failed to close logFile", Level.kWarning);
            }
            logFile = null;
        }

    }

    @Override
    public boolean isFinished() {

        // Get the robot's position
        Translation2d robotPosition = driveTrain.getPose().getTranslation();

        // Get the goal position
        Translation2d goalPosition = follower.getFinalPose();

        return RobotMath.epsilonEquals(robotPosition, goalPosition, new Translation2d(epsRadius, epsRadius));
    }

}